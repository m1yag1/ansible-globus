---
# Integration Example: Traditional GCS Setup + API Management
# This playbook shows how to extend your existing configure-gcs-servers.yml
# with the new Ansible Globus Collection for API-based resource management

- name: Install and Configure GCS (Traditional Approach)
  hosts: tag_Purpose_globus_connect_server
  become: true
  gather_facts: true
  roles:
    # Your existing role handles GCS software installation
    - globus-connect-server

- name: Manage Globus Resources via API (New Collection)
  hosts: tag_Purpose_globus_connect_server
  become: false
  gather_facts: false
  collections:
    - m1yag1.globus

  vars:
    # These should match your existing group_vars/all.yml structure
    globus_auth:
      client_id: "{{ globus_client_id }}"
      client_secret: "{{ globus_client_secret }}"
      # Note: scopes will be requested automatically by each module

  tasks:
    # Wait for GCS to be fully operational
    - name: Wait for GCS endpoint to be ready
      ansible.builtin.wait_for:
        port: 443
        host: "{{ ansible_default_ipv4.address }}"
        timeout: 300
        msg: "GCS HTTPS service did not come up within 5 minutes"

    # Create/update endpoint with your existing variables
    - name: Manage GCS Endpoint
      m1yag1.globus.globus_endpoint:
        auth: "{{ globus_auth }}"
        display_name: "{{ gcs_endpoint_name }}"
        description: "{{ gcs_endpoint_description | default('') }}"
        owner_string: "{{ endpoint_owner | default('') }}"
        state: present
      register: endpoint_result
      delegate_to: localhost

    - name: Debug endpoint creation result
      ansible.builtin.debug:
        var: endpoint_result
      when: endpoint_result is defined

    # Create collections using your existing gcs_collections variable
    - name: Manage GCS Collections
      m1yag1.globus.globus_collection:
        auth: "{{ globus_auth }}"
        endpoint_id: "{{ endpoint_result.endpoint.id }}"
        display_name: "{{ item.display_name }}"
        collection_base_path: "{{ item.base_path }}"
        description: "{{ item.description | default('') }}"
        delete_protected: "{{ item.delete_protected | default(false) }}"
        state: present
      loop: "{{ gcs_collections | default([]) }}"
      register: collections_result
      delegate_to: localhost
      when: gcs_collections is defined and gcs_collections | length > 0

    - name: Debug collections creation results
      ansible.builtin.debug:
        var: collections_result
      when: collections_result is defined

    # Create test users as Globus identities (if needed for testing)
    - name: Create test groups for user management
      m1yag1.globus.globus_group:
        auth: "{{ globus_auth }}"
        name: "{{ gcs_endpoint_name | regex_replace('[^a-zA-Z0-9]', '-') }}-test-users"
        description: "Test users for {{ gcs_endpoint_name }}"
        state: present
      register: test_group_result
      delegate_to: localhost
      when: globus_users is defined and globus_users | length > 0

    - name: Debug group creation result
      ansible.builtin.debug:
        var: test_group_result
      when: test_group_result is defined

# Optional: Verification tasks to ensure everything is working
- name: Verify GCS Setup
  hosts: tag_Purpose_globus_connect_server
  become: false
  gather_facts: false
  tasks:
    - name: Check GCS service status
      ansible.builtin.systemd:
        name: globus-connect-server
        state: started
      become: true
      check_mode: true
      register: gcs_service_status

    - name: Display GCS service status
      ansible.builtin.debug:
        msg: "GCS service is {{ 'running' if gcs_service_status.status.ActiveState == 'active' else 'not running properly' }}"
